#include "lua_iface.h"

#include <stdio.h>
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

#include "machine.h"
#include "vpu/fonts/bmfonts.h"
#include "lua/lua_config.h"

#include "vpu/vpu_tests.h"

struct mhdl {
    struct machine *M;
};

#define LEF_GET_MHDL(L) (luaL_checkudata((L), 1, BACH_LUA_MHNDL_NAME))

/* Lua standard libraries to load
 */
static const luaL_reg lualibs[] = {
    { "base",       luaopen_base },
    { NULL,         NULL }
};

/* Fwd decl (defined at end of this file) */
static const struct luaL_reg lib_funcs[];
static const struct luaL_reg lib_methods[];

/* Protos (private) */
static int loadscript(lua_State *L, const char *scriptname);
static lua_State *newluainstance(int *errhandler);
static void openlualibs(lua_State *L);
static int initexports(lua_State *L);
static int errorh(lua_State *L);
static void funcerror(lua_State *L, const char *errstr);
static int garbagecollect(lua_State *L);


/**********************************************************************
   C Public
 **********************************************************************/

int
zvm_lua_runscript(const char *filename)
{
    lua_State *L;
    int errhandler;

    if (filename == NULL || *filename == '\0') {
        fputs("Run Lua: error invalid filename\n", stderr);
        return 1;   /* invalid filename */
    }

    if ((L = newluainstance(&errhandler)) == 0)
        return 1;   /* fail */

    if (loadscript(L, filename) == 0) {
        lua_pcall(L, 0, 0, errhandler);
    }

    lua_close(L);

    return 0;
}


/**********************************************************************
   Functions NOT for use within (exported to) Lua (PRIVATE)
 **********************************************************************/
static int
loadscript(lua_State *L, const char *scriptname)
{
    int lr;

    if ((lr = luaL_loadfile(L, scriptname)) != 0) {
        fputs("Error loading ", stderr);
        fputs(scriptname, stderr);
        fputs(": ", stderr);
        switch (lr) {
        case LUA_ERRFILE:
            fputs("could not open file\n", stderr);
            break;
        case LUA_ERRSYNTAX:
            fputs("pre-compilation syntax error\n", stderr);
            break;
        case LUA_ERRMEM:
            fputs("memory allocation error\n", stderr);
            break;
        default:
            fputs("unknown error\n", stderr);
            break;
        }
        return 1;
     }
    return 0;   /* No error */
}

static lua_State *
newluainstance(int *errhandler)
{
    lua_State *L;

    /* Initialise interface */
    if ((L = lua_open()) == NULL) {
        fputs("Could not initialise Lua (memory error)\n", stderr);
        return NULL;
    }

    openlualibs(L);
    initexports(L);

    lua_pushcfunction(L, errorh);  /* push traceback function */
    *errhandler = lua_gettop(L);

    return L;
}

static void
openlualibs(lua_State *L)
{
    const luaL_reg *lib;

    for (lib = lualibs; lib->func != NULL; lib++) {
        lib->func(L);
        lua_settop(L, 0);
    }
}

static int
initexports(lua_State *L)
{
    static const struct luaL_reg *f;

    luaL_newmetatable(L, BACH_LUA_MHNDL_NAME);

    lua_pushvalue(L, -1);
    lua_setfield(L, -2, "__index");
    lua_pushcfunction(L, garbagecollect);
    lua_setfield(L, -2, "__gc");

    /* install methods into metatable */
    for (f = lib_methods; f->func != NULL && f->name != NULL; f++) {
        lua_pushcfunction(L, f->func);
        lua_setfield(L, -2, f->name);
    }

    lua_createtable(L, 1, 0);
    for (f = lib_funcs; f->func != NULL && f->name != NULL; f++) {
        lua_pushcfunction(L, f->func);
        lua_setfield(L, -2, f->name);
    }

    luaL_getmetatable(L, BACH_LUA_MHNDL_NAME);
    lua_setmetatable(L, -2);

    lua_setglobal(L, BACH_LUA_CLASS_NAME);

    return 1;
}

/* For errors generated by the Lua VM
 */
static int
errorh(lua_State *L)
{
    fputs(lua_tostring(L, 1), stderr);
    fputc('\n', stderr);

    return 0;
}

/* For errors generated by exported functions
 */
static void
funcerror(lua_State *L, const char *errstr)
{
    lua_Debug d;

    lua_getstack(L, 1, &d);
    lua_getinfo(L, "nSl", &d);

    lua_pushfstring(L, "Error. Lua line %d: %s", d.currentline, errstr);
    lua_error(L);
}

static int
garbagecollect(lua_State *L)
{
    struct mhdl *m = luaL_checkudata(L, 1, BACH_LUA_MHNDL_NAME);
    machine_destroy(&m->M);
    return 0;
}


/**********************************************************************
   Functions exported to Lua
 **********************************************************************/

static int
l_newmachine(lua_State *L)
{
    struct mhdl *m;

    m = lua_newuserdata(L, sizeof *m);
    luaL_getmetatable(L, BACH_LUA_MHNDL_NAME);
    lua_setmetatable(L, -2);

    m->M = machine_new();
    if (m->M == NULL)
        funcerror(L, "could not create new machine state");

    return 1;
}

static int
l_machine_poweron(lua_State *L)
{
    struct mhdl *m;
    const char *fontstr;

    struct machine_config cfg;

    /* Lua function args */
    m = LEF_GET_MHDL(L);

    cfg.video_pix_w = luaL_checkinteger(L, 2);
    cfg.video_pix_h = luaL_checkinteger(L, 3);
    cfg.fullscreen  = luaL_checkinteger(L, 4);
    fontstr         = luaL_checklstring(L, 5, NULL);

    if ((cfg.font = vidfont_getnamedfont(fontstr)) == NULL)
        funcerror(L, "invalid font specified");

    if (!machine_poweron(m->M, &cfg))
        funcerror(L, "machine already powered on");

    return 0;
}

static int
l_machine_poweroff(lua_State *L)
{
    struct mhdl *m;

    m = LEF_GET_MHDL(L);
    machine_poweroff(m->M);

    return 0;
}

static int
l_esys_waitforquit(lua_State *L)
{
    struct mhdl *m;

    m = LEF_GET_MHDL(L);
    evsys_waitforquit(m->M->esys);
    return 0;
}

/* --------------------------------------------------------------------
    Tests
   -------------------------------------------------------------------*/
#if VPU_BUILDTEST_TERRAIN == 1
static int
l_vputest_terrain(lua_State *L)
{
    (void)L;    /* UNUSED */
    vputest_genterrain();
    return 0;   /* no return values */
}
#endif

#if VPU_BUILDTEST_BASICCOLOURS == 1
static int
l_vputest_basiccolours(lua_State *L)
{
    (void)L;    /* UNUSED */
    vputest_basiccolours();
    return 0;   /* no return values */
}
#endif

#if VPU_BUILDTEST_SCROLL == 1
static int
l_vputest_scroll(lua_State *L)
{
    (void)L;    /* UNUSED */
    vputest_scroll();
    return 0;   /* no return values */
}
#endif

/* --------------------------------------------------------------------
   Lua export definitions
   -------------------------------------------------------------------*/

static const struct luaL_reg lib_methods[] = {

    /* ---- Machine  -------------------------------------------------*/

    { "poweron",            l_machine_poweron   },
    { "poweroff",           l_machine_poweroff  },

    /* ---- Event system ---------------------------------------------*/

    { "waitforquit",        l_esys_waitforquit  },



    /* ---- Tests ----------------------------------------------------*/

#if VPU_BUILDTEST_TERRAIN == 1
    { "vputest_terrain",        l_vputest_terrain       },
#endif
#if VPU_BUILDTEST_BASICCOLOURS == 1
    { "vputest_basiccolours",   l_vputest_basiccolours  },
#endif
#if VPU_BUILDTEST_SCROLL == 1
    { "vputest_scroll",         l_vputest_scroll        },
#endif
    { NULL, NULL }

};

static const struct luaL_reg lib_funcs[] = {
    { "newmachine",          l_newmachine       },
    { NULL, NULL }
};
